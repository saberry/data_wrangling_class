---
title: "Iteration"
format:
  html:
    toc: true
    toc-location: left
    theme: vapor
---

## Why

## How

### for loop

The humble for loop is likely the most flexible iterator known to humanity. You can find for loops in every programming. Even when the sytax is different the idea is exactly the same -- iterate over some data structure and perform some operation.

Before you see it, the for loop is essentially saying, "For every thing in this element, do the following task." In R, for loops are constructed like this:

```{r}
#| eval: false

for (iterator in data_structure) {
  # Do something
}
```

That object labeled `iterator` is a temporary variable that will take on the value of each element in the data structure -- you can call it anything you want, but you'll see most people call it `i`. The magic comes with `in data_structure` -- this is where you specify the data structure that you want to iterate over. This can be a vector, a list, a data.frame, or even a function.  

Let's forgo simple examples and jump right to stuff that you will encounter in the wild. Let's say that I want to fit a model to each of the variables in the `mtcars` dataset. I'll start by pre-allocating a data.frame to store my results. This pre-allocation will make for more efficient loops. You should **always** pre-allocate your data structures if you are not plugging things into an object that already exists.

```{r}
my_results <- data.frame(
  variable = colnames(mtcars)[-1], # I'll use the first column as the outcome
  r_squared = rep(NA, ncol(mtcars)-1),
  f_stat = rep(NA, ncol(mtcars)-1)
)
```

Now I can iterate over the variables in the `mtcars` dataset and store the results in my pre-allocated data.frame.

```{r}
for(variable in colnames(mtcars)[-1]) {
  model_summary <- summary(lm(mtcars[, "mpg"] ~ mtcars[, variable]))
  my_results$r_squared[my_results$variable == variable] <- model_summary$adj.r.squared
  my_results$f_stat[my_results$variable == variable] <- model_summary$fstatistic['value']
}
```

:::{.callout-note}
While I hope that the code above is a suitable demonstration, this is absolutely not a valid modeling technique in this century. 
:::

Let's return to that movie_review_text that gave us problems before.

```{r}
movie_reviews <- read.csv("data/movie_review_text.csv")

movie_reviews
```

We can start by identifying the `review_example` rows that are missing information.

```{r}
bad_reviews <- which(movie_reviews$review_example == "")
```

Now we can iterate over those row values to look in the previous row and paste the values together:

```{r}
for(review in bad_reviews) {
  movie_reviews$review_example[review - 1] <- paste(movie_reviews$review_example[review - 1], 
                                                movie_reviews$movie[review], 
                                                sep = "")  
}

movie_reviews <- movie_reviews[-bad_reviews, ]
```


### while loop

The `while` loop is very much like a for loop, but with some type of terminating condition. The syntax is as follows:

```{r}
stopping_value <- 10

while (stopping_value > 0) {
  print(stopping_value)
  stopping_value <- stopping_value - 1
}
```

The above loop will print the value of `stopping_value` until it reaches 0. 

### apply-family

The apply family offers a flexible way of doing it iterative work, while offering known outputs at the end of the statement. The apply family consists of the following functions:

- The `lapply` function takes a vector, performs an operation, and then returns the outcome in a list

- The `sapply` function takes a vector, performs an operation, and then returns the outcome in a vector

- The `tapply` function takes a vector, performs an operation, and then returns the outcome in a table

- The `mapply` function takes multiple arguments, performs an operation, and then returns the outcome in a format of your choosing!

:::{.callout-note}
You'll also see the `apply` function used sometimes, but I rarely find it useful.

```{r}
# Column means
apply(mtcars, 2, mean)

# Row means
apply(mtcars, 1, mean)
```
:::

```{r}
trains <- read.csv("data/Rail_Equipment_Accident_Incident_Data.csv")

my_vars <- c("Causing.Car.Number", "Causing.Car.Position", 
             "Positive.Alcohol.Tests", "Positive.Drug.Tests")

trains_sub <- trains[, my_vars]

# Find number of missing values in each row

trains_sub$missing <- sapply(
  1:nrow(trains_sub), 
  function(x) {
    sum(is.na(trains_sub[x, ]))
  })

# Substituting Missing Values with 0

trains_sub[, my_vars] <- lapply(my_vars, function(x) {
  ifelse(is.na(trains_sub[, x]), 0,  trains_sub[, x])
})

# Proportion Missing In Column

sapply(colnames(trains), function(x) {
  sum(is.na(trains[, x])) / nrow(trains)
})

```


```{r}
char_vars <- which(sapply(colnames(trains), function(x) is.character(trains[, x])) == TRUE)

summaries <- sapply(char_vars, function(x) sort(unique(trains[, x])))
```


### map_*

## Practice